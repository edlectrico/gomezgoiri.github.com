<!DOCTYPE html>
<html>
  <head>
    <title>Reusing Web-enabled Actuators from a Semantic Space-based Perspective</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <!--<base href="http://localhost:8000/">-->
    <base href="https://dl.dropboxusercontent.com/u/9804351/">
    <link rel="stylesheet" type="text/css" href="own-style.css" media="screen" />
  </head>
  <body>
    <textarea id="source">

class: center, frontpage

.frontcontent-outer[
 .frontcontent-inner[

# Reusing Web-enabled Actuators from a Semantic Space-based Perspective
## <u>Aitor Gómez Goiri</u>, Iñigo Goiri,  Diego López-de-Ipiña

.date[June 16, 2014]

  ]
]
???

Hello to everyone.

My name is... I come from the univ... to present the paper I made together with Iñigo and Diego entitled...

<!--
- --

# Outline

.weak[

1- Introduction

2- Hypothesis

3 - Space model

4- Search architecture

5- Actuation

]

6- Conclusions
-->
---

class: center, middle

# Introduction

---

# Background
.subtitle[
## Introduction
]

<img alt="And god said: let's make Internet" src="img/esiot/internet01.png" style="width: 90%; display: block; margin-top: 2em; margin-left: auto; margin-right: auto">

???

In the beginning Internet was composed by few computers.

---

# Background
.subtitle[
## Introduction
]
<img alt="Internet popularizes" src="img/esiot/internet02.png" style="width: 100%; display: block;">

???

Then, the __popularity__ of the Internet increased and connecting computers became __easier and cheaper__.

Consequently, __more and more__ computers got connected.

---

# Background
.subtitle[
## Introduction
]
<img alt="Wireless comes to the Internet" src="img/esiot/internet03.png" style="width: 100%; display: block;">

???

Thanks to __wireless__ technologies, devices started accessing to the Internet without having to be physically connected to a network.

---

# Background
.subtitle[
## Introduction
]
<img alt="Mobile computing appears" src="img/esiot/internet04.png" style="width: 100%; display: block;">

???

So the __mobile computing__ appeared.

---

# Background
.subtitle[
## Introduction
]
<img alt="The Internet of Things appears" src="img/esiot/internet05.png" style="width: 100%; display: block;">

???

Nowadays, __not only__ a wider range of smartphones, but also everyday objects like cars or washing machines connect to the Internet to exchange information.

This is what __is know as__ the Internet of Things (IoT).

Both IoT and the mobile computing have contributed to the __Ubicomp__ idea.

---

# UbiComp, challenge: heterogeneity
.subtitle[
## Introduction
]

<img alt="Dude, what are you talking about?" src="img/esiot/interoperability01.png" style="width: 100%; display: block;">

???

So, nowadays, we have __heterogeneous__ devices running on top of heterogeneous applications.

This means that the __interoperability__ is a key property for these environments.

---

# UbiComp, challenge: heterogeneity
.subtitle[
## Introduction
]

The [IEEE](http://ieeexplore.ieee.org/servlet/opac?punumber=2238) defines __interoperability__ as

 > The ability of two or more systems or components to __exchange__ information
 > and to __use__ the information that has been exchanged.

???

The [AI] triple [I] defines...
 
---

# UbiComp, challenge: heterogeneity
.subtitle[
## Introduction
]

The [IEEE](http://ieeexplore.ieee.org/servlet/opac?punumber=2238) defines __interoperability__ as

> .weak[The ability of two or more systems or components to _exchange_ information
> and to __use__ the information that has been exchanged.]

???

So, let's first talk about the second problem: how to use (or reuse) information.

---

# UbiComp, heterogeneity: use info
.subtitle[
## Introduction
]

<img alt="The robot does not understand chinese or japanese" src="img/esiot/interoperability02.png" style="width: 100%; display: block;">

???

We can identify two levels to allow this __use__:

 1. The  __syntactic__ level, which cares about  the format of the data (i.e. its syntax and encoding)
    * For instance, if the robot does not undestand chinese characters, the information the mobile phone provides will be useless.

 1. The __semantic__ level gives a precise meaning to the information...
    * _"understandable by any other application that was not initially developed for this purpose"_ <!-- TODO cite -->
    * Following the example, this character may mean different things depending on the context.

---


# UbiComp, heterogeneity: use info (solution)
.subtitle[
## Introduction
]

<img alt="The robot does understand terms" src="img/esiot/interoperability03.png" style="width: 100%; display: block;">

???

To achieve both levels, we propose to use __Semantic Web__ standards and tools.

The vision of the Semantic Web is to __extend__ principles of the __Web from documents to data__.

It __relates terms__to one another, so they can be shared and reused across applications.

This terms can be __processed automatically__ revealing __new relationships__ among the data.

 > .weak[The __vision__ of the Semantic Web is to extend principles of the Web from documents to data.
 > Data should be accessed using the general Web architecture using, e.g., URI-s;
 > data should be __related to one another__ just as documents (or portions of documents) are already.
 > This also means creation of a common framework that allows data
 > to be __shared and reused__ across application, enterprise, and community boundaries,
 > to be __processed automatically__ by tools as well as manually,
 > including revealing possible __new relationships__ among pieces of data.]

---

# UbiComp, heterogeneity:  exchange info
.subtitle[
## Introduction
]

The [IEEE](http://ieeexplore.ieee.org/servlet/opac?punumber=2238)  defines _interoperability_ as

 > .weak[The ability of two or more systems or components to __exchange__ information
 > and to _use_ the information that has been exchanged.]


???

The other aspect which affects the interoperability is __how to exchange information__.

Rather than focusing on __low-level__ communication protocols,
this paper analyses __more general__ communication strategies.


---

# Exchange info 1: the Web
.subtitle[
## Introduction > UbiComp, heterogeneity
]
<img alt="The web is widely accepted" src="img/esiot/web_accepted01.png" style="width: 100%;" />

???

The first way is the web.

The web is massively accepted <!--by humans. (this is not a real reason) -->

 * By humans
 * But also, by machines: a lot of applications expose their capabilities using HTTP APIs

__REST__ architectural style comprises the design principles of _the modern web_

---

# Exchange info 1: the Web
.subtitle[
## Introduction > UbiComp, heterogeneity
]
<img alt="The web is widely accepted" src="img/esiot/web_accepted02.png" style="width: 100%;" />

???

It achieves the following properties  (see Fielding's thesis)

* Scalability
* Simplicity
* Portability
* etc.

Note that most of these properties are particularly useful for limited devices.

---

# Exchange info 1: the Web
.subtitle[
## Introduction > UbiComp, heterogeneity
]

<img alt="The web of Things" src="img/esiot/wot.png" style="width: 100%; display: block;">

???

As a consequence, the web has been widely applied to IoT, bringing what people has called the __Web of Things__ (WoT).

<!-- Transpa backup: WoT challenges: push approach, subscription mechanisms... -->

In the WoT, everyday things expose their capabilities through web standards.
This way, they are first-class web citizens and can seamlessly work with other web apps.

---

# Exchange info 2: Tuple Spaces
.subtitle[
## Introduction > UbiComp, heterogeneity
]
<img alt="Space-based computing: rd, in and out primitives" src="img/esiot/space_based01.png" style="width: 100%;">

???

A second way to exchange info is space-based computing (or Tuple Spaces).

Tuple Spaces is a paradigm where nodes coordinate with each other by writing and reading structured pieces of information (i.e., tuples) in a shared space.

---

# Exchange info 2: Tuple Spaces
.subtitle[
## Introduction > UbiComp, heterogeneity
]
<img alt="Space-based computing: space and time uncoupled" src="img/esiot/space_based02.png" style="width: 100%;">

???

This paradigm can be uncoupled in space and in time.

---

# Exchange info 2: Tuple Spaces
.subtitle[
## Introduction > UbiComp, heterogeneity
]
<img alt="Space-based computing: space uncoupled" src="img/esiot/space_based03.png" style="width: 100%;">

???

__Space uncoupling__ is achieved because the nodes don't need to know each other beforehand to communicate.

That is, TS' primitives do not care about addresses and references, they just care about the content which is being shared.

When the computer writes the circle does not know which one node use this piece of info.

---

# Exchange info 2: Tuple Spaces
.subtitle[
## Introduction > UbiComp, heterogeneity
]
<img alt="Space-based computing: space uncoupled" src="img/esiot/space_based04.png" style="width: 100%;">

???

Similarly, if the umbrella reads a circle, it does not know which one generated this concrete blue circle.

---

# Exchange info 2: Tuple Spaces
.subtitle[
## Introduction > UbiComp, heterogeneity
]
<img alt="Space-based computing: space uncoupled" src="img/esiot/space_based05.png" style="width: 100%;">

???

__Time uncoupling__ is achieved because two nodes communicating with each other do not need to coexist at the same time.

For instance, after writing the pentagon...

---

# Exchange info 2: Tuple Spaces
.subtitle[
## Introduction > UbiComp, heterogeneity
]
<img alt="Space-based computing: space uncoupled" src="img/esiot/space_based06.png" style="width: 100%;">

???

...the laptop might left the space.

For instance, because it run out of battery of it phisically left the room.

---

# Exchange info 2: Tuple Spaces
.subtitle[
## Introduction > UbiComp, heterogeneity
]
<img alt="Space-based computing: space uncoupled" src="img/esiot/space_based07.png" style="width: 100%;">

???

Then, an umbrella might join the space.

---

# Exchange info 2: Tuple Spaces
.subtitle[
## Introduction > UbiComp, heterogeneity
]
<img alt="Space-based computing: space uncoupled" src="img/esiot/space_based08.png" style="width: 100%;">

???

If it ask for a pentagon, it will get the one written by the laptop even if it is not present.

Thanks to these uncoupling levels, TS faces dynamism successfully both in the short and in the long term.

---

class: center, middle

# Actuation
## How to produce a change in the space?

---

# Patterns for Tuple Spaces
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns01.png" style="width: 100%;" />

???

To solve this question I first examined the common Tuple Spaces' usage patterns.

For sake of brevity, I will present just two of them.

---

# Patterns for Tuple Spaces
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns02.png" style="width: 100%;" />

???

The first one is the __replicated-worker pattern__.

In this pattern, there is a master process and many worker processes able to compute the same task.

---

# Patterns for Tuple Spaces
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns03.png" style="width: 100%;" />

???

First, the master takes a problem, divides it into smaller tasks, and

---

# Patterns for Tuple Spaces
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns04.png" style="width: 100%;" />

???

writes these tasks into the space.

---

# Patterns for Tuple Spaces
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns05.png" style="width: 100%;" />

???

Then, any available worker takes a task,

---

# Patterns for Tuple Spaces
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns06.png" style="width: 100%;" />

???

processes it,

---

# Patterns for Tuple Spaces
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns07.png" style="width: 100%;" />

???

and writes the result back into the space.

---

# Patterns for Tuple Spaces
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns08.png" style="width: 100%;" />

???

As the workers write their results, the master takes these results from the space.

---

# Patterns for Tuple Spaces
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns09.png" style="width: 100%;" />

???

When the master has collected all the results, it combines them into a meaningful merged solution.

This pattern is scalable and naturally balances the load on the space.

---

# Patterns for Tuple Spaces
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns10.png" style="width: 100%;" />

???

The second pattern in the __specialist pattern__.

It can be seen as a variation of the previous one.

The difference is that in this pattern each worker is specialized and knows how to make a particular task.

---

# Patterns for Tuple Spaces in UbiComp
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns11.png" style="width: 100%;" />

???

We can translate the previous patterns to the UbiComp usage examples.

---

# Patterns for Tuple Spaces in UbiComp
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns12.png" style="width: 100%;" />

???

For instance, a smartphone may write the task "turn the fan on" into the space.

---

# Patterns for Tuple Spaces in UbiComp
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns13.png" style="width: 100%;" />

???

A smart-fan which belongs to the same space, will then take the task,

---

# Patterns for Tuple Spaces in UbiComp
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/ts_patterns14.png" style="width: 100%;" />

???

process it and as a result activate the blades.

Then, it may write a result in the space that the "activator node" will read.

For example, with information about when it was turned on.

.weak[This approach has been widely applied in the literature.
In the past, this idea evolved into service-oriented engines.
The task-types where described through services and task through _service invocations_.]


---

# HTTP API
.subtitle[
## Actuation
]

<div style="margin-top: 5em;"></div>

```http
POST /blades HTTP/1.1
Host: smartfan.eu
true
```

???


However, the more I read about WoT, the more I liked its simplicity.

For example, for the fan, we could simply make a HTTP POST request to the smart-fan.

Unfortunately, like most of the resource-oriented API, this per-se would not be REST-compliant.

---

# HTTP API
.subtitle[
## Actuation
]
<img alt="REST APÎ describes current state and possible transitions" src="img/esiot/hypermedia_driven01.png" style="width: 100%;" />

???

To make the API hypermedia-driven, the application has to describe

* the current state and
* the transitions to the next ones.

This way, the client can __select__ the __next state__ of the application through __hypermedia__.

---

# HTTP API
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/hypermedia_driven02.png" style="width: 100%;" />

???

When the __client is a human__, it's easy for him to interpret the HTML content and decide __which link__ to follow or which __button__ to press.

---

# HTTP API
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/hypermedia_driven03.png" style="width: 100%;" />

???

However, doing this automatically (without human intervention) is currently a hot research topic.

Some solutions propose to use the semantic web to describe these applications and state transitions.

In this paper, we used a solution called RESTdesc.

---

# RESTdesc
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/restdesc_rule01.png" style="width: 70%;" />

???

RESTdesc describes HTTP methods using rules expressed in the Notation 3 language (or N3).

In the figure, we can see a description for a HTTP GET method.

It explains how to obtain a light measure.

---

# RESTdesc
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/restdesc_rule02.png" style="width: 70%;" />

???

A rule’s premise expresses the requirements to make an state transition.

---

# RESTdesc
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/restdesc_rule03.png" style="width: 70%;" />

???

A rule’s conclusion expresses both

* the REST call that needs to be made and...

---

# RESTdesc
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/restdesc_rule04.png" style="width: 70%;" />

???

...the description of what we can expect as a result of the request.

---

# RESTdesc
.subtitle[
## Actuation
]

```http
OPTIONS /deustotech/lights HTTP/1.1
Host: deusto.eu
```

```http
HTTP/1.0 200 OK
Date: Sat, 14 Jun 2014 21:22:01 GMT
Content-type: text/n3; charset=UTF-8
Content-Length: 512

{
 actuators:light ssn:madeObservation ?light_obs .
} => {
 _:request http:methodName "GET" ;
 http:requestURI ?light_obs ;
 http:resp [ http:body ?light_obs ].
 ?light_obs a ssn:Observation ;
 ssn:observedProperty sweet:Light ;
...

```

???

These descriptions can be obtained through different mechanisms.

We will assume that they are provided in the same resources which it describes.

To this end, we can use the HTTP OPTIONS verb.

---

# RESTdesc
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/restdesc_how01.png" style="width: 95%;" />

???

So, when a client has crawled an API collecting several of these descriptions, what can we do with them?

IF we also have...

---

# RESTdesc
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/restdesc_how02.png" style="width: 95%;" />

???

... background knowledge expressed with semantics, and...

---

# RESTdesc
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/restdesc_how03.png" style="width: 95%;" />

???

__a goal__, which is an special rule which expresses the ending state we want to reach;

---

# RESTdesc
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/restdesc_how04.png" style="width: 95%;" />

???

THEN we can use a reasoner to make an execution plan.

Personally, I have used the EYE reasoner.

---

# RESTdesc
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/restdesc_how05.png" style="width: 95%;" />

???

This plan indicates different paths to __reach the desired goal__ (or final state).
Let's assume that there is only one path (or no path).

This path will contain different steps composed by the rules which need to be invoked to obtain a plan.

And since these rules are composed by the HTTP requests, we just have to check if we can invoke them.

---

# Motivation
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/hypermedia_driven03.png" style="width: 100%;" />

???

In short, machines can learn how to use an API autonomously using RESTdesc.

That is, RESTdesc becomes APIs hypermedia-driven.

The main advantage of an hypermedia-driven API is that it can change its _shape_ over the time and the applications automatically consuming it will not need to be reconfigured or redeveloped.

Translating it to the WoT field, it will allow to act using actuators not known at the design or implementation phases.

---

# Comparison
.subtitle[
## Actuation
]

<table style="margin-top:3em;">
  <thead>
    <tr class="first_row">
      <td style="width:7em">Actuation</td>
      <td style="width:8em">Communication style</td>
      <td style="width:7em">Benefits</td>
      <td>Required features</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Space-based</td>
      <td>Indirect</td>
      <td>Decoupling</td>
      <td>Subscriptions</td>
    </tr>
    <tr>
      <td>REST-based</td>
      <td>Direct</td>
      <td>Reuse</td>
      <td>Rule-based reasoning</td>
    </tr>
  </tbody>
</table>

???

The two actuation techniques presented are quite distinct in nature.

---

# Comparison
.subtitle[
## Actuation
]

<table style="margin-top:3em;">
  <thead>
    <tr class="first_row">
      <td style="width:7em">Actuation</td>
      <td style="width:8em">Communication style</td>
      <td style="width:7em">Benefits</td>
      <td>Required features</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Space-based</td>
      <td><strong>Indirect</strong></td>
      <td>Decoupling</td>
      <td>Subscriptions</td>
    </tr>
    <tr>
      <td>REST-based</td>
      <td><strong>Direct</strong></td>
      <td>Reuse</td>
      <td>Rule-based reasoning</td>
    </tr>
  </tbody>
</table>

???

One promotes the direct communication style, while the other promotes an indirect uncoupled style.

.weak[

* Decoupled communication
* Reuse of third-party WoT apps

]

---

# Comparison
.subtitle[
## Actuation
]

<table style="margin-top:3em;">
  <thead>
    <tr class="first_row">
      <td style="width:7em">Actuation</td>
      <td style="width:8em">Communication style</td>
      <td style="width:7em">Benefits</td>
      <td>Required features</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Space-based</td>
      <td>Indirect</td>
      <td>Decoupling</td>
      <td><strong>Subscriptions</strong></td>
    </tr>
    <tr>
      <td>REST-based</td>
      <td>Direct</td>
      <td>Reuse</td>
      <td><strong>Rule-based reasoning</strong></td>
    </tr>
  </tbody>
</table>

???

We can also see in the table how each of them require additional features:

* A subscription mechanism in the case of space-based computing.
 This mechanism helps nodes to be aware of what is written into the space without constantly polling it.
* A reasoner to create a execution plan,


So I made myself the following question: could space-based computing take advantage of these existing REST-based actuators?

Furthermore, could this reuse be made in a seamless way for nodes already following each of these techniques?

---

# Driving scenario
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/actuation_scenario.png" style="width: 100%;" />

???

As a first step to answer this question, I planned a baseline scenario and implemented it using both mechanisms.

The scenario is the "helloworld" of the scenarios: turning on and off a light.

However, it helps to understand both actuation mechanisms and test the interoperation ideas.

---

# Comparison
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/requests_by_techniques.svg" style="width: 100%; margin-top: 5%;" />

???

After implementing both scenarios, I calculated how the variation in the number of providers (e.g., actuators) could affect these techniques.

First, we can see that as the amount of actuators increases, both techniques generate more requests.
The slope will vary depending on the design (and implementation) of each solution.
In any case, the figure shows that none of the techniques behave in a scalable manner.

In the case of space-based actuation, the variation corresponds to the subscription request of each actuator and two additional writings it does. <!-- FIXME comprobar que es así -->

In the case of REST-based actuation the crawler needs to obtain 5 different rules for each actuator.

---

# Comparison
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/raspberry-pi-model-b.jpg" style="width:60%; margin-top:1em;" class="center" />
<table style="margin-top:1em;">
  <tr>
    <td style="width:9em">Platform</td>
    <td>Raspberry Pi (model B)</td>
  </tr>
  <tr>
    <td>RAM Memory</td>
    <td>512 MB</td>
  </tr>
  <tr>
    <td>CPU</td>
    <td>700 MHz Low Power ARM1176JZ-F Applications Processor</td>
  </tr>
</table>

???

To check how much computing resources each techniques requires, I tested them in a Raspberry Pi.

Again, the scenario was tested with 1 to a thousand actuators.

---

# Comparison
.subtitle[
## Actuation
]

<img alt="XXX" src="img/esiot/performance_by_techniques.svg" style="width: 100%; margin-top: 10%;" />

???

In the chart, we see that the amount of actuators affects more severely to __REST__-based actuation.

This is due to the to the reasoning process which takes place in the node which generates the plan.

In __space__-based actuation, most of the time is spent checking subscriptions at each write.

Note that even if the subscription mechanism was unoptimized due to its prototyping nature, it made space-based actuation scale much better.

---

# Comparison
.subtitle[
## Actuation
]

<table style="margin-top:3em;">
  <thead>
    <tr>
      <td style="width:7em">Actuation</td>
      <td style="width:7em">Perspective</td>
      <td colspan="2" style="text-align:center; width:18em">Activity</td>
    </tr>
    <tr class="first_row">
      <td></td>
      <td></td>
      <td style="text-align:center; width:10em">Networking</td>
      <td style="text-align:center; width:8em">Computation</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="3">Space-based</td>
      <td>Provider</td>
      <td>Proactive, limited</td>
      <td>Limited</td>
    </tr>
    <tr>
      <td>Consumer</td>
      <td>Proactive, limited</td>
      <td>Limited</td>
    </tr>
    <tr>
      <td>Space</td>
      <td>Reactive, high</td>
      <td>Varies</td>
    </tr>
    <tr>
      <td rowspan="2">REST-based</td>
      <td>Provider</td>
      <td>Reactive, limited</td>
      <td>Limited</td>
    </tr>
    <tr>
      <td>Consumer</td>
      <td>Proactive, high</td>
      <td>Demanding</td>
    </tr>
  </tbody>
</table>
???

Considering these results and after analysing the characteristics of both techniques, we came out to the following table.

It summarizes the strengths and weaknesses of both techniques.

---

# Comparison
.subtitle[
## Actuation
]

<table style="margin-top:3em;">
  <thead>
    <tr>
      <td style="width:7em">Actuation</td>
      <td style="width:7em">Perspective</td>
      <td colspan="2" style="text-align:center; width:18em">Activity</td>
    </tr>
    <tr class="first_row">
      <td></td>
      <td></td>
      <td style="text-align:center; width:10em">Networking</td>
      <td style="text-align:center; width:8em">Computation</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="3">Space-based</td>
      <td>Provider</td>
      <td>Proactive, limited</td>
      <td>Limited</td>
    </tr>
    <tr>
      <td><strong>Consumer</strong></td>
      <td>Proactive, <strong>limited</strong></td>
      <td><strong>Limited</strong></td>
    </tr>
    <tr>
      <td>Space</td>
      <td>Reactive, high</td>
      <td>Varies</td>
    </tr>
    <tr>
      <td rowspan="2">REST-based</td>
      <td>Provider</td>
      <td>Reactive,limited</td>
      <td>Limited</td>
    </tr>
    <tr>
      <td><strong>Consumer</strong></td>
      <td>Proactive, <strong>high</strong></td>
      <td><strong>Demanding</strong></td>
    </tr>
  </tbody>
</table>
???

From the actuator point of view, the previous charts have already shown its higher activity compared to space-based actuation.

---

# Comparison
.subtitle[
## Actuation
]

<table style="margin-top:3em;">
  <thead>
    <tr>
      <td style="width:7em">Actuation</td>
      <td style="width:7em">Perspective</td>
      <td colspan="2" style="text-align:center; width:18em">Activity</td>
    </tr>
    <tr class="first_row">
      <td></td>
      <td></td>
      <td style="text-align:center; width:10em">Networking</td>
      <td style="text-align:center; width:8em">Computation</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="3">Space-based</td>
      <td>Provider</td>
      <td>Proactive, limited</td>
      <td>Limited</td>
    </tr>
    <tr>
      <td>Consumer</td>
      <td>Proactive, limited</td>
      <td>Limited</td>
    </tr>
    <tr>
      <td>Space</td>
      <td>Reactive, high</td>
      <td>Varies</td>
    </tr>
    <tr>
      <td rowspan="2"><strong>REST</strong>-based</td>
      <td><strong>Provider</strong></td>
      <td>Reactive, <strong>limited</strong></td>
      <td><strong>Limited</strong></td>
    </tr>
    <tr>
      <td>Consumer</td>
      <td>Proactive, high</td>
      <td>Demanding</td>
    </tr>
  </tbody>
</table>
???

The table shows how the providers in the second actuation mechanism are more lightweight.

That is, they just attend to the request received using HTTP.

Probably as a consequence of these few requirements, exposing the actuation capabilities of the limited devices with HTTP is a consolidated trend.
.weak[This tendency is backed by the WoT initiative.]

REST-desc only requires devices to additionally provide their API's resources' descriptions.

This can be done before deploying them and does not affect to their usual operation.

---

# Interoperation
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/mixed_actuation01.png" style="width: 100%;" />
???

With these considerations in mind, I propose a solution which completely reuses the nodes implemented for the previous actuation techniques.

In the left hand side, we see a master node from Space-based actuation which writes the "turn light on" task.

---

# Interoperation
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/mixed_actuation02.png" style="width: 100%;" />
???

In the right hand side, we see a smart-bulb light which exposes their actuation capabilities through an HTTP API.

---

# Interoperation
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/mixed_actuation03.png" style="width: 100%;" />
???

This API is described using RESTdesc.

In my dissertation, I propose not to altere the existing nodes.

Therefore, the space needs to be extended to make their interoperability possible.

---

# Interoperation: how?
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/mixed_actuation04.png" style="width: 100%;" />
???

And... how is it extended?

The space will be responsible of:

* Translating a _subscription to a task result_ into a reasoning goal.
 Considering the how I implemented the subscriptions .weak[(based on SPARQL using RDFLib)], this is a straightforward syntactic translation .weak[(from SPARQL to N3QL for EYE)].

---

# Interoperation: how?
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/mixed_actuation05.png" style="width: 100%;" />
???

Apart from this, it will be in charge of two tasks performed by the client in REST-based actuation:

 * crawl APIs to obtain RESTdesc rules and

---

# Interoperation: how?
.subtitle[
## Actuation
]
<img alt="XXX" src="img/esiot/mixed_actuation06.png" style="width: 100%;" />
???

 * create a plan.

Note one benefitial aspect: as the process resides in the same machine as the space, it can locally read all the content written into the space.

This content is provided as additional knowledge to the reasoning process.

This way, we avoid additional costly networking operations (both in bandwidth and in time) to obtain this knowledge.

---

# Discussion
.subtitle[
## Actuation
]

1. Obtaining background knowledge
1. Triggering REST actuation
1. From subscription to result to goal

 * More general from task to result.

???

---

# Discussion
.subtitle[
## Actuation
]

Further investigation with more complex scenarios is needed:

* Is the __translation__ between the subscriptions and the goal always possible?
* If the plan has __2 or more paths__ to achieve a goal, which one should we chose?
* What if __two different actuators__ from space-based and rest-based actuation can be activated?

???

However, the hybrid-actuation technique presented needs further investigation to ensure its universality.

For example,

* Would the translation between the subscriptions and the goal always be possible?
 .weak[What if the node initiating the change does not subscribe to any result?]

* If there are two or more paths to reach a goal, how can we discern which one to follow?
 .weak[This problem is specific to the REST actuation using REST-desc.]

* How does the middleware deal with the coexistence of both mechanisms?
 When both methods can be applied, which one is triggered?
 .weak[Which one prevails over the other?]


In any case, I analysed actuation in space-based computing from a novel-point of view.

From the space-based consumer perspective, I proposed to seamlessly reuse actuators from the WoT.

---

class: center, middle

# Conclusion

???

To conclude, let me present my contributions and conclusions.

---

# Future work

* Are __limited__ devices just __dumb__ devices unable to manage semantic annotations?
* __Do__ we really __need the Semantic Web__?
* Will true-__REST__-architectures ever __prevail__?

???

To end this presentation, let me comment some considerations.

* From my experience, nowadays there are __not many__ embedded or mobile devices able to manage the semantic web successfully.
 * However, recent works on lightweight reasoning, communication protocols or semantic formats, can __considerably reduce__ the computing requirements needed.
* The second is that I have the impression that we sometimes __look down on__ interoperability.
 * .weak[Causes: impossibility to perceive its benefits in the short term and privacy concerns]
 * However, the __Linked Data__ initiative is slowly changing this perception.
* Finally, although __REST-like__ architectures are very popular nowadays, the need of making them hypermedia-driven is not shared by many web developers.
 * And this is a pity, because otherwise __using__ third-party web applications' __automatically__ would be much closer.
 * .weak[Razonamiento: in this case, the industry will put pressure on the academia {akadimia}]

---

class: middle, questionslide

# Questions?
Aitor Gómez Goiri .breakline[ aitor.gomez (at) [deusto (dot) es](http://www.deusto.es)]

???

With this I conclude my presentation and I am ready to answer the questions and comments you make regarding this dissertation.

Thank you very much for listening.

---

class: center, middle

All rights of images are reserved by the <br />
__original owners__*, the rest of the content is licensed <br />
under a __[Creative Commons by-sa 3.0](http://creativecommons.org/licenses/by-sa/3.0/)__ license.

<div style="margin-top:3em"/>

![Creative commons by-sa 3.0 license logo](img/CC-logo.svg)

<div style="margin-top:3em"/>

\* [leogg](http://openclipart.org/detail/89209/),
[rduris](http://openclipart.org/detail/167948/),
[williamtheaker](http://openclipart.org/detail/178310/) and
[cibo00](http://openclipart.org/detail/14056/).


---

class: center, middle

# Backup slides

---

# "Short" or "limited" are relative adjectives <!-- IoT? Energy-aware? -->
.subtitle[
## Motivation
]
<img alt="XXX" src="img/esiot/dunk-portrait-2006.jpg" class="center" style="width: 20em;"/>
<!-- Explain: which devices, results for semantic web testings, the evolution experienced since I first started working in this -->

???

The player in the center is Nate Robinson who, compared to any of the remaining NBA players will be considered small.

However, he is about 4 cm taller than me, so I wouldn't consider him small.

The same thing happens when we speak about _limited devices_.

In the context of my dissertation, _limited devices_ are mobile or embedded devices able to manage semantic annotations.

---

# The Semantic Web and limited devices

* semantic reasoners for this type of environments (mencionar al tio que hizo un razonador adaptado)
* lightweight semantic formats
* lightweight web protocols
* mobile and embedded devices' the processing capability
* [autonomy of the batteries](http://energi.us/liberacion-patentes-tesla/) or
* energy harvesting
* large etc.

???

Some of our attempts with several platforms (e.g., Arduino) where unsuccessful.

However, with current advances in:

[leer]

More and more devices will be able to manage semantics.
 <!--
 TODO
 Preparar una transpa de backup por si preguntan cómo de viable es.
 Ideas:
   * Many of the current devices are able to manage their info
   * Gráfico con pruebas que hicimos en su día:
    * Even if it is more verbosed
    * Some of them can reason and expand this information.
    * Others may need to rely in third machines.
     * Out of the scope
    * Anyway, we might be anticipating a trend.
 -->

    </textarea>
    <!--<script src="http://gnab.github.io/remark/downloads/remark-0.5.9.min.js" type="text/javascript">-->
    <script src="remark-0.5.9.min.js" type="text/javascript">
    </script>
    <!-- Substitute with remark-latest.min.js -->
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
